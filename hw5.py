import json
import pathlib
from typing import Union, Tuple, Optional
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        self.data_fname = pathlib.Path(data_fname) if isinstance(data_fname, str) else data_fname
        self.data = None

    def read_data(self):
        """Reads the JSON data located in self.data_fname into memory."""
        with open(self.data_fname, 'r') as f:
            self.data = pd.DataFrame(json.load(f))

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants."""
        if self.data is None:
            raise ValueError("Data not loaded. Use the read_data method first.")

        self.data['age'] = pd.to_numeric(self.data['age'], errors='coerce')
        ages = self.data['age'].dropna()
        bins = np.arange(0, 101, 10)
        hist, bin_edges = np.histogram(ages, bins=bins)

        plt.figure(figsize=(8, 6))
        plt.hist(ages, bins=bins, edgecolor='black', alpha=0.7)
        plt.title("Age Distribution of Participants")
        plt.xlabel("Age")
        plt.ylabel("Number of Participants")
        plt.xticks(bins)
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.show()

        return hist, bin_edges

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them."""
        if self.data is None:
            raise ValueError("Data not loaded. Use the read_data method first.")

        def is_valid_email(email: str) -> bool:
            if not isinstance(email, str):
                return False
            if email.count('@') != 1 or email.startswith('@') or email.endswith('@'):
                return False
            if '.' not in email or email.startswith('.') or email.endswith('.'):
                return False
            if email[email.index('@') + 1] == '.':
                return False
            return True

        valid_emails = self.data['email'].apply(is_valid_email)
        self.data = self.data[valid_emails].reset_index(drop=True)
        return self.data

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds subjects with missing answers and replaces them with the mean of other grades."""
        if self.data is None:
            raise ValueError("Data not loaded. Use the read_data method first.")

        question_columns = [col for col in self.data.columns if col.startswith('q')]
        rows_with_na = self.data[question_columns].isna().any(axis=1)

        def replace_na_with_mean(row):
            if row.isna().any():
                mean_value = row.dropna().mean()
                return row.fillna(mean_value)
            return row

        self.data[question_columns] = self.data[question_columns].apply(replace_na_with_mean, axis=1)
        corrected_indices = np.where(rows_with_na)[0]

        return self.data, corrected_indices

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates the average score of a subject and adds a new "score" column
        with it.

        If the subject has more than "maximal_nans_per_sub" NaN in his grades, the
        score should be NA. Otherwise, the score is simply the mean of the other grades.
        The datatype of score is UInt8, and the floating point raw numbers should be
        rounded down.

        Parameters
        ----------
        maximal_nans_per_sub : int, optional
            Number of allowed NaNs per subject before giving a NA score.

        Returns
        -------
        pd.DataFrame
            A new DF with a new column - "score".
        """
        if self.data is None:
            raise ValueError("Data not loaded. Use the read_data method first.")

        # Select columns corresponding to the questions (assuming they are named q1, q2, ..., q5)
        question_columns = [col for col in self.data.columns if col.startswith('q')]

        # Ensure question columns contain only numeric data
        self.data[question_columns] = self.data[question_columns].apply(pd.to_numeric, errors='coerce')

        def calculate_score(row):
            # Count the number of NaNs in the row
            nans_count = row.isna().sum()
            if nans_count > maximal_nans_per_sub:
                return np.nan  # Assign NA if NaNs exceed the threshold
            # Calculate the mean of non-NaN values and round down
            return np.floor(row.dropna().mean())

        # Apply the scoring function to each row
        self.data['score'] = self.data[question_columns].apply(calculate_score, axis=1)

        # Convert the score column to UInt8
        self.data['score'] = self.data['score'].astype(pd.UInt8Dtype(), errors='ignore')

        return self.data


if __name__ == "__main__":
    analysis = QuestionnaireAnalysis("data.json")
    analysis.read_data()

    # Example usage of methods
    cleaned_data = analysis.remove_rows_without_mail()
    print("\nCleaned Data:")
    print(cleaned_data)

    corrected_data, corrected_indices = analysis.fill_na_with_mean()
    print("\nCorrected Data:")
    print(corrected_data)
    print("Corrected Indices:")
    print(corrected_indices)

    scored_data = analysis.score_subjects(maximal_nans_per_sub=1)
    print("\nScored Data:")
    print(scored_data)