import json
import pathlib
import pandas as pd
import numpy as np
from typing import Union, Tuple


class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        if isinstance(data_fname, str):
            data_fname = pathlib.Path(data_fname)
        if not isinstance(data_fname, pathlib.Path):
            raise TypeError("data_fname must be a string or pathlib.Path object.")
        if not data_fname.exists():
            raise ValueError(f"File not found: {data_fname}")

        self.data_fname = data_fname
        self.data = None  

    def read_data(self):
        with open(self.data_fname, "r", encoding="utf-8") as f:
            raw_data = json.load(f)
        df = pd.DataFrame(raw_data)

        df.replace("nan", np.nan, inplace=True)

        df["age"] = pd.to_numeric(df["age"], errors="coerce")
        for q in ["q1", "q2", "q3", "q4", "q5"]:
            df[q] = pd.to_numeric(df[q], errors="coerce")

        self.data = df

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants."""
        valid_ages = self.data["age"].dropna()
        bins = np.arange(0, 101, 10) 
        hist, bin_edges = np.histogram(valid_ages, bins=bins)
        return hist, bin_edges

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them."""
        def is_valid_email(email: str) -> bool:
            if not isinstance(email, str):
                return False
            if email.startswith('@') or email.endswith('@'):
                return False
            if email.startswith('.') or email.endswith('.'):
                return False
            if email.count('@') != 1:
                return False
            if '.' not in email:
                return False
            local, domain = email.split('@', 1)
            if domain.startswith('.'):
                return False
            return True

        df = self.data.copy()
        mask = df['email'].apply(is_valid_email)
        cleaned_df = df[mask].reset_index(drop=True)
        return cleaned_df

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Replaces missing question grades with the subject's mean grade."""
        df = self.data.copy()
        question_cols = [col for col in df.columns if col.startswith("q")]
        corrected_indices = []

        for idx, row in df.iterrows():
            row_questions = row[question_cols]
            if row_questions.isnull().any():
                mean_val = row_questions.mean()
                df.loc[idx, question_cols] = row_questions.fillna(mean_val)
                corrected_indices.append(idx)

        return df, np.array(corrected_indices)

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates the average score of a subject and adds a new 'score' column."""
        df = self.data.copy()
        question_cols = [col for col in df.columns if col.startswith("q")]

        def compute_score(row):
            num_nans = row[question_cols].isna().sum()
            if num_nans > maximal_nans_per_sub:
                return pd.NA
            mean_score = np.floor(row[question_cols].mean())
            return pd.NA if pd.isna(mean_score) else int(mean_score)

        df['score'] = df.apply(compute_score, axis=1)
        df['score'] = df['score'].astype('UInt8', errors='ignore')
        return df