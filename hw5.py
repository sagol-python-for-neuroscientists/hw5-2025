import pathlib
from typing import Union, Dict, Any,Tuple,List
import json
import numpy as np
import pandas as pd
import re

class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        """
        Initializes the QuestionnaireAnalysis object with the path to the
        data file.

        :param data_fname: Path to the json file containing questionnaire data.
        """
        if isinstance(data_fname, str):
            if not pathlib.Path(data_fname).exists():
                raise ValueError(f"File {data_fname} not found.")
            self.data_fname = pathlib.Path(data_fname)
        elif isinstance(data_fname, pathlib.Path):
            if not data_fname.exists():
                raise ValueError(f"File {data_fname} not found.")
            self.data_fname = data_fname
        else:
            raise TypeError("data_fname must be a string or pathlib.Path object")
        

        self.data: List[Dict[str, Any] ]= []




    def read_data(self):
        """Reads the json data located in self.data_fname into memory, to
        the attribute self.data.
        """
        if not self.data_fname.exists():
            raise FileNotFoundError(f"Data file {self.data_fname} does not exist.")
        
        with self.data_fname.open('r', encoding='utf-8') as f:
            self.data: List[Dict[str, Any]] = json.load(f)
            #change self.data to a dataframe ,where each key in the dictionary is a column
            #size of len of keys and number of dictionaries
            alphs = list(self.data[0].keys())
            self.data = pd.DataFrame(self.data, columns=alphs)
            # Convert all literal "nan" strings to actual NaNs
            self.data.replace("nan", np.nan, inplace=True)

        
        #return self.data
    
    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants
            
            Returns
            -------
            hist : np.ndarray
            Number of people in a given bin
            bins : np.ndarray
            Bin edges

        """
        if self.data.empty:
            self.read_data()
        # Check if ids are present in a number format
        self.data['age'] = pd.to_numeric(self.data['age'].replace("nan", np.nan), errors='coerce')
        self.data = self.data.dropna(subset=['age']).astype({'age': float})
                
        valid_ages = self.data.loc[self.data['age'].between(1, 101), 'age']

        if valid_ages.empty:
            raise ValueError("No valid ages found in the data.")
        #filter out invalid ages
        ages = [age for age in self.data['age'] if 0 < age < 101]
        
        if not ages:
            raise ValueError("No valid ages found in the data.")
        # Calculate histogram
        
        bins_edges=np.arange(0, 101, 10)
        hist, bins = np.histogram(ages, bins=bins_edges)
        
        return hist, bins
    
    def check_sign_exists(self,df: pd.DataFrame, sign: str) -> pd.DataFrame:
        """Checks if a given sign exists in the email address.
            Parameters
            ----------
            df : pd.DataFrame
                DataFrame containing the email column.
            sign : str
                The sign to check for in the email addresses.

            Returns
            -------
            pd.DataFrame
                DataFrame with rows where the email contains the sign correctly.
                
        """
        pattern = re.escape(sign)
        # Check if email have the sign, not at the start or end and only once
        if not isinstance(df, pd.DataFrame):
            raise TypeError("df must be a pandas DataFrame")
        df= df[(df['email'].str.contains(pattern)) &
                (df['email'].str.strip().str.startswith(sign) == False) &
                (df['email'].str.strip().str.endswith(sign) == False)]
        # Check if the sign appears only once if sign is '@' else check if at least once
        if sign == '@':
            df = df[df['email'].str.count(sign) == 1]
        return df
    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Checks self.data for rows with invalid emails, and removes them.

            Returns
            -------
            df : pd.DataFrame
            A corrected DataFrame, i.e. the same table but with the erroneous rows removed and
            the (ordinal) index after a reset.
        """
        if self.data.empty:
            self.read_data()
        
        # Create DataFrame from participants data
        df = self.data
        
        # Check for missing or invalid emails
        if 'email' not in df.columns:
            raise ValueError("No 'email' column found in the data.")
        
        # Remove rows with invalid emails
        df = df[df['email'].notnull()]
        sign_lis=['@','.']
        # Check if email contains '@' and '.'
        for sign in sign_lis:
            df = self.check_sign_exists(df, sign)
        #avoid emails that . is right after @
        df = df[~df['email'].str.contains(r'@\.')]
        #also remove rows where there is a space in the email
        
        df.reset_index(drop=True, inplace=True)
        if df.empty:
            raise ValueError("No valid emails found in the data.")
        return df
    
    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Finds, in the original DataFrame, the subjects that didn't answer
        all questions, and replaces that missing value with the mean of the
        other grades for that student.

        Returns
        -------
        df : pd.DataFrame
        The corrected DataFrame after insertion of the mean grade
        arr : np.ndarray
            Row indices of the students that their new grades were generated
        """
        if self.data.empty:
            self.read_data()
        
        # Create DataFrame from participants data
        df = self.data.copy()
        #look for "nan" in 7 to the end of the columns
        cols = df.columns[7:]

        nan_rows = df[cols].isna().any(axis=1)
  
        #go through the rows with "nan" values
        for index, row in df[nan_rows].iterrows():
            # Get the mean of the row excluding NaN values
            mean_value = row[cols].mean()
            # Fill NaN values with the mean
            df.loc[index, cols] = row[cols].fillna(mean_value)


        arr = df[nan_rows].index.to_numpy()
        #print(f'len of arr: {len(arr)}')
        
        return df, arr


    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates the average score of a subject and adds a new "score" column
        with it.

        If the subject has more than "maximal_nans_per_sub" NaN in his grades, the
        score should be NA. Otherwise, the score is simply the mean of the other grades.
        The datatype of score is UInt8, and the floating point raw numbers should be
        rounded down.

        Parameters
        ----------
        maximal_nans_per_sub : int, optional
            Number of allowed NaNs per subject before giving a NA score.

        Returns
        -------
        pd.DataFrame
            A new DF with a new column - "score".
        """
        if self.data.empty:
            self.read_data()
        
        # Create DataFrame from participants data
        df = self.data.copy()
        
        # Calculate the score for each subject
        cols = df.columns[7:]
         # Compute scores with floor; assign pd.NA if too many NaNs
        df['score'] = df[cols].apply(
            lambda row: np.floor(row.mean()) if row.isna().sum() <= maximal_nans_per_sub else pd.NA,
            axis=1
        )
        #round down the score
        df['score'] = df['score'].apply(lambda x: np.floor(x) if pd.notna(x) else pd.NA)
        # Convert score to UInt8
        df['score'] = df['score'].astype('UInt8')

        return df
    
    
    def correlate_gender_age(self) -> pd.DataFrame:
        """Looks for a correlation between the gender of the subject, their age
        and the score for all five questions.

        Returns
        -------
        pd.DataFrame
            A DataFrame with a MultiIndex containing the gender and whether the subject is above
            40 years of age, and the average score in each of the five questions.
        """
        if self.data.empty:
            self.read_data()
        #even though its easier to just fo groupby and get mulyiindex with means
        #we will fulfill the requirements of the task to the letter
        #section after section
        #section a : from original dataframe create multiindex dataframe
        df=self.data.copy()
        #df, _ = self.fill_na_with_mean()
        #use the fill_na_with_mean to fill NaN values
        #remove rows with "nan" in the age column
        df['age'] = pd.to_numeric(df['age'], errors='coerce')  # Ensure age is numeric
        df = df[df['age'].notna()]  # Filter out rows where age is NaN
        
        
        df.reset_index(drop=False, inplace=True)
        #multiindex with rows, gender and age
        df.set_index(['index', 'gender', 'age'], inplace=True)
        df.index.names = ['row_index', 'gender', 'age']
        #section b : create a new column 'above_40' that is True if age > 40
        # use it to get mean scores for each group in each question sepreated by age 40
        df['above_40'] = df.index.get_level_values('age').astype(float) > 40
        
        q_cols = [f'q{i}' for i in range(1, 6)]
        #remove age column
        #relevant_df.drop(columns=['age'], inplace=True)
        
        # Calculate the mean score for each group
        mean_scores = df.groupby(['gender', 'above_40'])[q_cols].mean()
        #section c : "Return the DataFrame containing the average result per question per group "
        #set name of above_40 to 'age'
        mean_scores.index = mean_scores.index.set_names(['gender', 'age'])
        print(mean_scores)

        return mean_scores


    


        
        

