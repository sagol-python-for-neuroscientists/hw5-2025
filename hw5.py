# hw5.py

import json
import pathlib
from typing import Union, Tuple

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

class QuestionnaireAnalysis:
    """
    Reads and analyzes data generated by the questionnaire experiment.
    Should be able to accept strings and pathlib.Path objects.
    """

    def __init__(self, data_fname: Union[pathlib.Path, str]):
        # Validate input type
        if not isinstance(data_fname, (str, pathlib.Path)):
            raise TypeError(f"Expected str or pathlib.Path, got {type(data_fname)}")
        
        # Always store as Path object for consistency
        self.data_fname = pathlib.Path(data_fname)

        # Check if file exists
        if not self.data_fname.exists():
            raise ValueError(f"File {self.data_fname} does not exist")

        self.data = None

    def read_data(self):
        """Reads the json data located in self.data_fname into memory."""
        with open(self.data_fname, 'r') as f:
            json_data = json.load(f)
        self.data = pd.DataFrame(json_data)

        # Replace string "nan" with proper NaN values
        self.data = self.data.replace('nan', np.nan)

        # Convert question and age columns to numeric
        numeric_cols = ['age', 'q1', 'q2', 'q3', 'q4', 'q5']
        self.data[numeric_cols] = self.data[numeric_cols].apply(pd.to_numeric, errors='coerce')

    def show_age_distrib(self) -> Tuple[np.ndarray, np.ndarray]:
        """Calculates and plots the age distribution of the participants."""
        bins = np.arange(0, 101, 10)
        ages = self.data['age'].dropna()
        hist, bin_edges = np.histogram(ages, bins=bins)

        plt.figure(figsize=(10, 6))
        plt.hist(ages, bins=bins, edgecolor='black', alpha=0.7)
        plt.xlabel('Age')
        plt.ylabel('Number of Participants')
        plt.title('Age Distribution of Participants')
        plt.xticks(bins)
        plt.grid(True, alpha=0.3)
        plt.show()

        return hist, bin_edges

    def remove_rows_without_mail(self) -> pd.DataFrame:
        """Removes rows with invalid emails."""
        def is_valid_email(email):
            if pd.isna(email) or not isinstance(email, str):
                return False
            # Check for exactly one @ symbol
            if email.count('@') != 1 or email.startswith('@') or email.endswith('@'):
                return False
            # Check for at least one dot
            if '.' not in email or email.startswith('.') or email.endswith('.'):
                return False
            # Make sure there's no dot right after @
            at_index = email.index('@')
            if at_index + 1 < len(email) and email[at_index + 1] == '.':
                return False
            # Basic domain validation
            local_part, domain_part = email.split('@')
            if not local_part or not domain_part or '.' not in domain_part:
                return False
            # Check for empty parts in domain
            for part in domain_part.split('.'):
                if not part:
                    return False
            return True

        valid_mask = self.data['email'].apply(is_valid_email)
        df_cleaned = self.data[valid_mask].copy().reset_index(drop=True)
        return df_cleaned

    def fill_na_with_mean(self) -> Tuple[pd.DataFrame, np.ndarray]:
        """Replaces missing question grades with the student's mean grade."""
        df = self.data.copy()
        grade_cols = [c for c in df.columns if c.startswith('q')]
        
        # Find which rows have missing values
        na_mask = df[grade_cols].isna().any(axis=1)
        indices = na_mask[na_mask].index.to_numpy()
        
        # Fill missing values with row means
        for idx in indices:
            row = df.loc[idx, grade_cols]
            mean_val = row.mean(skipna=True)
            df.loc[idx, grade_cols] = row.fillna(mean_val)
            
        return df, indices

    def score_subjects(self, maximal_nans_per_sub: int = 1) -> pd.DataFrame:
        """Calculates the average score per subject with NA handling."""
        df = self.data.copy()
        grade_cols = [c for c in df.columns if c.startswith('q')]
        
        # Count missing values per student
        n_nans = df[grade_cols].isna().sum(axis=1)
        
        # Calculate averages
        mean_scores = df[grade_cols].mean(axis=1, skipna=True)
        
        # Round down to integers
        floored = np.floor(mean_scores)
        
        # Set score to NA if too many missing values
        score = pd.Series(floored.where(n_nans <= maximal_nans_per_sub), dtype='UInt8')
        
        df['score'] = score
        return df

    def correlate_gender_age(self) -> pd.DataFrame:
        """
        Looks for a correlation between gender, age (>40), and the average
        answer in each of the five questions.

        Steps:
        a. Use the original DataFrame and transform its index into a MultiIndex with three levels:
           the ordinal index (row number), gender, and age_flag (True if age>40).
        b. Allocate the subjects into groups based on two parameters: their gender, and whether
           their age is above (>40) or below/equal 40.
        c. Return a DataFrame containing the average result per question (q1..q5) for each group.

        Returns
        -------
        pd.DataFrame
            A DataFrame indexed by (gender, age_flag) where age_flag is a boolean (True if age>40),
            containing the mean of q1..q5 per group (ignoring NaNs).
        """
        # Create working copy with reset index
        df = self.data.copy().reset_index()
        # Remove rows where age is missing
        df = df[df['age'].notna()]
        df['age_flag'] = df['age'] > 40

        # Create MultiIndex as required
        df = df.set_index(['index', 'gender', 'age_flag'])
        question_cols = [c for c in df.columns if c.startswith('q')]
        
        # Group by gender and age category
        grouped = df.groupby(level=['gender', 'age_flag'])[question_cols].mean()

        # Rename for cleaner output
        grouped.index.set_names(['gender', 'age'], inplace=True)
        return grouped